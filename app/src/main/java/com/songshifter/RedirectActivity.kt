package com.songshifter

import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

class RedirectActivity : AppCompatActivity() {
    private lateinit var preferencesHelper: PreferencesHelper
    private lateinit var statusText: TextView
    private lateinit var progressOverlay: View
    
    companion object {
        private const val TAG = "RedirectActivity"
        private const val SPOTIFY_PACKAGE = "com.spotify.music"
        private const val YOUTUBE_MUSIC_PACKAGE = "com.google.android.apps.youtube.music"
        
        // URL patterns
        private const val SPOTIFY_TRACK_PATTERN = "open.spotify.com/track"
        private const val SPOTIFY_SEARCH_PATTERN = "open.spotify.com/search"
        private const val YOUTUBE_MUSIC_WATCH_PATTERN = "music.youtube.com/watch"
        private const val SHAZAM_SONG_PATTERN = "shazam.com/song"
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_redirect)

        statusText = findViewById(R.id.status_text)
        progressOverlay = findViewById(R.id.progress_overlay)

        preferencesHelper = PreferencesHelper(this)
        handleIntent(intent)
    }
    
    override fun onNewIntent(intent: Intent) {
        super.onNewIntent(intent)
        handleIntent(intent)
    }
    
    private fun handleIntent(intent: Intent) {
        val url = intent.data?.toString()
        if (url == null) {
            Log.e(TAG, "No URL provided")
            finish()
            return
        }
        
        Log.d(TAG, "üì• Received URL: $url")
        
        // Check if this is a URL we generated ourselves
        val isOurGeneratedUrl = isAppGeneratedUrl(url)
        if (isOurGeneratedUrl) {
            Log.d(TAG, "üîÑ Detected our own generated URL, directly launching target app")
            launchTargetApp(url)
            finish()
            return
        }
        
        if (url.contains(YOUTUBE_MUSIC_WATCH_PATTERN) && isYouTubeMusicEnabled()) {
            showYouTubeMusicWarning()
            finish()
            return
        }
        
        if (!shouldRedirect(url)) {
            Log.d(TAG, "üîÑ Redirection not needed for this URL, relaying to original app")
            relayToOriginalApp(url)
            finish()
            return
        }
        
        processRedirection(url)
    }
    
    /**
     * Checks if the URL was generated by our app (e.g. search URLs)
     */
    private fun isAppGeneratedUrl(url: String): Boolean {
        // Check if this is a Spotify search URL we generated
        if (url.contains(SPOTIFY_SEARCH_PATTERN)) {
            val preferredPlatform = preferencesHelper.getPreferredPlatform()
            if (preferredPlatform == PreferencesHelper.PLATFORM_SPOTIFY) {
                Log.d(TAG, "‚úÖ Detected our generated Spotify search URL")
                return true
            }
        }
        
        // Check if this is a YouTube Music search URL we generated
        if (url.contains("music.youtube.com/search")) {
            val preferredPlatform = preferencesHelper.getPreferredPlatform()
            if (preferredPlatform == PreferencesHelper.PLATFORM_YOUTUBE_MUSIC) {
                Log.d(TAG, "‚úÖ Detected our generated YouTube Music search URL")
                return true
            }
        }
        
        return false
    }
    
    /**
     * Launches the appropriate app for a URL we generated ourselves
     */
    private fun launchTargetApp(url: String) {
        try {
            Log.d(TAG, "üöÄ Directly launching target app for URL: $url")
            
            val targetPackage = when {
                url.contains("open.spotify.com") -> SPOTIFY_PACKAGE
                url.contains("music.youtube.com") -> YOUTUBE_MUSIC_PACKAGE
                else -> null
            }
            
            if (targetPackage != null && isAppInstalled(targetPackage)) {
                val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url)).apply {
                    setPackage(targetPackage)
                    addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                }
                startActivity(intent)
                Log.d(TAG, "‚úÖ Successfully launched $targetPackage")
            } else {
                // Instead of using the system's default handler which might redirect back to us,
                // explicitly try to launch in a browser to break the redirect loop
                val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(url)).apply {
                    addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    // Explicitly exclude our package to prevent redirect loops
                    addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS)
                }
                
                // Get a list of browsers
                val browserActivities = packageManager.queryIntentActivities(browserIntent, 0)
                if (browserActivities.isNotEmpty()) {
                    // Find a browser that is not our app
                    val browserPackage = browserActivities.firstOrNull { 
                        it.activityInfo.packageName != packageName &&
                        !it.activityInfo.packageName.contains("songshifter")
                    }?.activityInfo?.packageName
                    
                    if (browserPackage != null) {
                        // Set the browser package explicitly
                        browserIntent.setPackage(browserPackage)
                        startActivity(browserIntent)
                        Log.d(TAG, "‚úÖ Launched URL in browser: $browserPackage")
                    } else {
                        // No suitable browser found, try generic intent
                        startActivity(browserIntent)
                        Log.d(TAG, "‚úÖ Launched URL in system browser (fallback)")
                    }
                } else {
                    // No browsers available, try generic intent
                    startActivity(browserIntent)
                    Log.d(TAG, "‚úÖ Launched URL in system browser (no browsers found)")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error launching target app: ${e.message}", e)
            showErrorAndExit("Could not open target app: ${e.message}")
        }
    }
    
    private fun processRedirection(url: String) {
        when {
            url.contains(YOUTUBE_MUSIC_WATCH_PATTERN) -> {
                Log.d(TAG, "üéµ YouTube Music URL detected")
                showProgress("Extracting song info...")
                extractAndRedirect(url)
            }
            url.contains(SPOTIFY_TRACK_PATTERN) -> {
                Log.d(TAG, "üéµ Spotify URL detected")
                showProgress("Extracting song info...")
                extractAndRedirect(url)
            }
            else -> {
                Log.d(TAG, "‚ùì Unknown URL type, finishing")
                finish()
            }
        }
    }
    
    private fun extractAndRedirect(url: String) {
        lifecycleScope.launch {
            try {
                Log.d(TAG, "‚öôÔ∏è Starting song info extraction from: $url")
                val songInfo = MusicLinkExtractor.extractSongInfo(this@RedirectActivity, url)
                
                if (songInfo != null) {
                    val preferredPlatform = preferencesHelper.getPreferredPlatform()
                    Log.d(TAG, "‚úÖ Extraction successful! Title: '${songInfo.title}', Artist: '${songInfo.artist}'")
                    Log.d(TAG, "üéØ Target platform: $preferredPlatform")
                    
                    showProgress("Opening in preferred app...")
                    
                    // Small delay to show the opening message
                    withContext(Dispatchers.IO) {
                        Thread.sleep(500)
                    }
                    
                    try {
                        // Build a simple search URL
                        val searchQuery = Uri.encode("${songInfo.title} ${songInfo.artist}".trim())
                        
                        if (preferredPlatform == PreferencesHelper.PLATFORM_SPOTIFY) {
                            // Simple direct Spotify approach
                            try {
                                val spotifyUri = "spotify:search:$searchQuery"
                                
                                // Check if Spotify is really installed
                                val isSpotifyReallyInstalled = isAppInstalled(SPOTIFY_PACKAGE)
                                Log.d(TAG, "üß™ Thorough check: Is Spotify really installed? $isSpotifyReallyInstalled")
                                
                                if (!isSpotifyReallyInstalled) {
                                    // If Spotify is installed but disabled, we need to detect that too
                                    val isSpotifyDisabled = isSpotifyInstalledButDisabled()
                                    
                                    if (isSpotifyDisabled) {
                                        Log.e(TAG, "‚ùå Spotify is installed but disabled")
                                        showSpotifyDisabledPrompt()
                                        return@launch
                                    } else {
                                        Log.e(TAG, "‚ùå Spotify is not installed")
                                        showSpotifyInstallPrompt()
                                        return@launch
                                    }
                                }
                                
                                val intent = Intent(Intent.ACTION_VIEW, Uri.parse(spotifyUri))
                                intent.setPackage(SPOTIFY_PACKAGE)
                                startActivity(intent)
                                Log.d(TAG, "‚úÖ Launched Spotify search")
                            } catch (e: Exception) {
                                Log.e(TAG, "‚ùå Failed to launch Spotify: ${e.message}")
                                showWrongConfigAlert(preferredPlatform)
                            }
                        } else if (preferredPlatform == PreferencesHelper.PLATFORM_YOUTUBE_MUSIC) {
                            // Simple direct YouTube Music approach
                            try {
                                val youtubeUri = "youtube-music://search?q=$searchQuery"
                                
                                // Check if YouTube Music is really installed AND enabled
                                val isYTMusicReallyInstalled = isAppInstalled(YOUTUBE_MUSIC_PACKAGE)
                                Log.d(TAG, "üß™ Thorough check: Is YouTube Music really installed? $isYTMusicReallyInstalled")
                                
                                if (!isYTMusicReallyInstalled) {
                                    // If YouTube Music is installed but disabled, we need to detect that too
                                    val isYTMusicDisabled = isYouTubeMusicDisabled()
                                    
                                    if (isYTMusicDisabled) {
                                        Log.e(TAG, "‚ùå YouTube Music is installed but disabled")
                                        showYouTubeMusicEnablePrompt()
                                        return@launch
                                    } else {
                                        Log.e(TAG, "‚ùå YouTube Music is not installed")
                                        showYouTubeMusicInstallPrompt()
                                        return@launch
                                    }
                                }
                                
                                val intent = Intent(Intent.ACTION_VIEW, Uri.parse(youtubeUri))
                                intent.setPackage(YOUTUBE_MUSIC_PACKAGE)
                                startActivity(intent)
                                Log.d(TAG, "‚úÖ Launched YouTube Music search")
                            } catch (e: Exception) {
                                Log.e(TAG, "‚ùå Failed to launch YouTube Music: ${e.message}")
                                
                                // Try fallback approach using regular search intent
                                try {
                                    Log.d(TAG, "üîÑ Trying fallback approach for YouTube Music with regular search Intent")
                                    val searchIntent = Intent(Intent.ACTION_SEARCH)
                                    searchIntent.setPackage(YOUTUBE_MUSIC_PACKAGE)
                                    searchIntent.putExtra("query", "${songInfo.title} ${songInfo.artist}".trim())
                                    startActivity(searchIntent)
                                    Log.d(TAG, "‚úÖ Fallback approach for YouTube Music succeeded")
                                    return@launch
                                } catch (e2: Exception) {
                                    Log.e(TAG, "‚ùå Fallback approach for YouTube Music failed: ${e2.message}")
                                    
                                    // Try another fallback using web URL
                                    try {
                                        Log.d(TAG, "üîÑ Trying second fallback approach for YouTube Music with web URL")
                                        val query = Uri.encode("${songInfo.title} ${songInfo.artist}".trim())
                                        
                                        // First check if this would cause a circular redirection
                                        val testIntent = Intent(Intent.ACTION_VIEW, 
                                            Uri.parse("https://music.youtube.com/search?q=test"))
                                        val resolveInfoList = packageManager.queryIntentActivities(testIntent, 0)
                                        
                                        // Check if our own app would intercept this
                                        val wouldCauseCircularRedirection = resolveInfoList.any { resolveInfo ->
                                            resolveInfo.activityInfo.packageName == packageName ||
                                            resolveInfo.activityInfo.packageName.contains("songshifter") ||
                                            resolveInfo.activityInfo.packageName.contains("songshifter")
                                        }
                                        
                                        if (wouldCauseCircularRedirection) {
                                            Log.e(TAG, "‚ö†Ô∏è Detected potential circular redirection for YouTube Music web URL")
                                            
                                            // Show more informative message to the user
                                            Toast.makeText(
                                                this@RedirectActivity,
                                                "Warning: Another app (possibly SongShifter) is intercepting YouTube Music links. " +
                                                "Please disable it in Settings > Apps > Link handling.",
                                                Toast.LENGTH_LONG
                                            ).show()
                                            
                                            // Try a last resort approach with explicit package targeting
                                            try {
                                                val startAppIntent = packageManager.getLaunchIntentForPackage(YOUTUBE_MUSIC_PACKAGE)
                                                if (startAppIntent != null) {
                                                    Log.d(TAG, "üîÑ Trying last resort approach: Just launching YouTube Music app")
                                                    startActivity(startAppIntent)
                                                    
                                                    // Show instructions to search manually
                                                    Toast.makeText(
                                                        this@RedirectActivity,
                                                        "Please search for: ${songInfo.title} by ${songInfo.artist}",
                                                        Toast.LENGTH_LONG
                                                    ).show()
                                                    return@launch
                                                }
                                            } catch (e: Exception) {
                                                Log.e(TAG, "‚ùå Last resort approach failed: ${e.message}")
                                            }
                                            
                                            // If we get here, show the error
                                            showCircularRedirectionError()
                                            return@launch
                                        }
                                        
                                        // No circular redirection detected, try the web URL approach
                                        val webIntent = Intent(Intent.ACTION_VIEW, 
                                            Uri.parse("https://music.youtube.com/search?q=$query"))
                                        webIntent.setPackage(YOUTUBE_MUSIC_PACKAGE)
                                        startActivity(webIntent)
                                        Log.d(TAG, "‚úÖ Second fallback approach for YouTube Music succeeded")
                                        return@launch
                                    } catch (e3: Exception) {
                                        Log.e(TAG, "‚ùå Second fallback approach for YouTube Music failed: ${e3.message}")
                                        showWrongConfigAlert(preferredPlatform)
                                    }
                                }
                            }
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "‚ùå Error during redirection: ${e.message}")
                        showErrorAndExit("Error during redirection: ${e.message}")
                    }
                } else {
                    Log.e(TAG, "‚ùå Failed to extract song info")
                    showErrorAndExit("Could not extract song information")
                }
            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Error during extraction: ${e.message}")
                showErrorAndExit("Error during extraction: ${e.message}")
            } finally {
                finish()
            }
        }
    }
    
    private fun showWrongConfigAlert(platform: String) {
        val message = when (platform) {
            PreferencesHelper.PLATFORM_SPOTIFY -> "Please make sure Spotify is installed and configured correctly."
            PreferencesHelper.PLATFORM_YOUTUBE_MUSIC -> "Could not search in YouTube Music. Try opening YouTube Music manually and searching for the song."
            else -> "Please check your app configuration."
        }
        showErrorAndExit(message)
    }
    
    private fun launchInBrowser(url: String) {
        Log.d(TAG, "üåê Launching in browser: $url")
        
        // Find a browser that isn't our app
        val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(url)).apply {
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }
        
        val browsers = packageManager.queryIntentActivities(browserIntent, 0)
            .filter { !it.activityInfo.packageName.contains(packageName) }
        
        if (browsers.isNotEmpty()) {
            // Use the first browser that isn't our app
            val browser = browsers.first()
            Log.d(TAG, "üåê Using browser: ${browser.activityInfo.packageName}")
            
            browserIntent.setPackage(browser.activityInfo.packageName)
            startActivity(browserIntent)
        } else {
            // No browser found, try system default
            try {
                startActivity(browserIntent)
                Log.d(TAG, "‚úÖ Launched in system default browser")
            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Error launching browser: ${e.message}")
                showErrorAndExit("Could not open a web browser")
            }
        }
    }
    
    private fun trySpotifyAlternateApproach(songInfo: SongInfo) {
        try {
            Log.d(TAG, "üîÑ Trying alternate approach for Spotify")
            // Spotify URI format: spotify:search:query
            val query = Uri.encode("${songInfo.title} ${songInfo.artist}".trim())
            val spotifyUri = "spotify:search:$query"
            
            Log.d(TAG, "üîç Spotify URI: $spotifyUri")
            
            val intent = Intent(Intent.ACTION_VIEW).apply {
                setData(Uri.parse(spotifyUri))
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            }
            
            startActivity(intent)
            Log.d(TAG, "‚úÖ Alternate approach succeeded")
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Alternate approach failed: ${e.message}", e)
            showErrorAndExit("Could not open Spotify")
        }
    }
    
    private fun isAppInstalled(packageName: String): Boolean {
        return try {
            // First check if the package exists at all
            packageManager.getPackageInfo(packageName, 0)
            
            // For Spotify, we need a more reliable way to check if it's installed
            if (packageName == SPOTIFY_PACKAGE) {
                // Try to get installed packages that can handle spotify: URI
                val intent = Intent(Intent.ACTION_VIEW, Uri.parse("spotify:"))
                val activities = packageManager.queryIntentActivities(intent, 0)
                val hasSpotifyHandler = activities.any { it.activityInfo.packageName == SPOTIFY_PACKAGE }
                
                Log.d(TAG, "üì± Checking Spotify installation - activities handling spotify: URI: ${activities.size}, hasSpotifyHandler: $hasSpotifyHandler")
                
                // Fallback method: check if the app info exists
                if (!hasSpotifyHandler) {
                    val appInfo = packageManager.getApplicationInfo(SPOTIFY_PACKAGE, 0)
                    val isEnabled = appInfo.enabled
                    Log.d(TAG, "üì± Fallback Spotify check - isEnabled: $isEnabled")
                    return isEnabled
                }
                
                return hasSpotifyHandler
            } 
            // For YouTube Music, check if it can handle youtube-music: scheme
            else if (packageName == YOUTUBE_MUSIC_PACKAGE) {
                // First check if app is enabled using the more reliable method
                val appInfo = packageManager.getApplicationInfo(YOUTUBE_MUSIC_PACKAGE, 0)
                val isEnabled = appInfo.enabled
                val enabledSetting = packageManager.getApplicationEnabledSetting(YOUTUBE_MUSIC_PACKAGE)
                val isReallyEnabled = isEnabled && enabledSetting != PackageManager.COMPONENT_ENABLED_STATE_DISABLED
                
                Log.d(TAG, "üì± YouTube Music check - isEnabled: $isEnabled, enabledSetting: $enabledSetting, isReallyEnabled: $isReallyEnabled")
                
                // If the app is not enabled, return false immediately
                if (!isReallyEnabled) {
                    return false
                }
                
                // Now try the URI scheme check, but don't fail if this doesn't work
                try {
                    val intent = Intent(Intent.ACTION_VIEW, Uri.parse("youtube-music:"))
                    val activities = packageManager.queryIntentActivities(intent, 0)
                    val hasYouTubeMusicHandler = activities.any { it.activityInfo.packageName == YOUTUBE_MUSIC_PACKAGE }
                    
                    Log.d(TAG, "üì± Checking YouTube Music installation - activities handling youtube-music: URI: ${activities.size}, hasHandler: $hasYouTubeMusicHandler")
                    
                    // Even if no handler found, we'll rely on the enabled check above
                    if (!hasYouTubeMusicHandler) {
                        Log.d(TAG, "üì± No handler for youtube-music: URI, but app is enabled so treating as installed")
                    }
                } catch (e: Exception) {
                    Log.d(TAG, "üì± Error checking youtube-music: URI, but app is enabled so treating as installed: ${e.message}")
                }
                
                // Return true based on the enabled check we already did, not the URI handler check
                return isReallyEnabled
            } 
            // Generic check for other packages
            else {
                val appInfo = packageManager.getApplicationInfo(packageName, 0)
                return appInfo.enabled
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error checking if app $packageName is installed: ${e.message}")
            false
        }
    }
    
    private fun relayToOriginalApp(url: String) {
        try {
            Log.d(TAG, "üîÑ Relaying URL to original app: $url")
            
            val targetPackage = when {
                url.contains("music.youtube.com") -> YOUTUBE_MUSIC_PACKAGE
                url.contains("open.spotify.com") -> SPOTIFY_PACKAGE
                else -> null
            }
            
            if (targetPackage != null && isAppInstalled(targetPackage)) {
                Log.d(TAG, "üéØ Target package for relay: $targetPackage")
                val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url)).apply {
                    setPackage(targetPackage)
                    addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                }
                startActivity(intent)
                Log.d(TAG, "‚úÖ Successfully relayed to $targetPackage")
            } else {
                // Use system default if target app not installed, but avoid redirect loops
                Log.d(TAG, "‚ö†Ô∏è Target app not installed, using system handler with browser detection")
                val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(url)).apply {
                    addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    // Explicitly exclude our package to prevent redirect loops
                    addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS)
                }
                
                // Get a list of browsers
                val browserActivities = packageManager.queryIntentActivities(browserIntent, 0)
                if (browserActivities.isNotEmpty()) {
                    // Find a browser that is not our app
                    val browserPackage = browserActivities.firstOrNull { 
                        it.activityInfo.packageName != packageName &&
                        !it.activityInfo.packageName.contains("songshifter")
                    }?.activityInfo?.packageName
                    
                    if (browserPackage != null) {
                        // Set the browser package explicitly
                        browserIntent.setPackage(browserPackage)
                        startActivity(browserIntent)
                        Log.d(TAG, "‚úÖ Relayed URL to browser: $browserPackage")
                    } else {
                        // No suitable browser found, try generic intent
                        startActivity(browserIntent)
                        Log.d(TAG, "‚úÖ Relayed URL to system browser (fallback)")
                    }
                } else {
                    // No browsers available, try generic intent
                    startActivity(browserIntent)
                    Log.d(TAG, "‚úÖ Relayed URL to system browser (no browsers found)")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error relaying to original app: ${e.message}", e)
            showErrorAndExit("Could not open original app")
        }
    }
    
    private fun shouldRedirect(url: String): Boolean {
        val preferredPlatform = preferencesHelper.getPreferredPlatform()
        val allEnabled = preferencesHelper.isAllRedirectionsEnabled()
        
        if (!allEnabled) {
            Log.d(TAG, "üö´ All redirections disabled")
            return false
        }
        
        return when {
            url.contains(SPOTIFY_TRACK_PATTERN) -> {
                val result = preferencesHelper.isSpotifyRedirectionEnabled() && 
                            preferredPlatform != PreferencesHelper.PLATFORM_SPOTIFY
                Log.d(TAG, "üîç Spotify track URL, should redirect: $result (preferred platform: $preferredPlatform)")
                result
            }
            url.contains(YOUTUBE_MUSIC_WATCH_PATTERN) -> {
                val result = preferencesHelper.isYouTubeMusicRedirectionEnabled() && 
                            preferredPlatform != PreferencesHelper.PLATFORM_YOUTUBE_MUSIC
                Log.d(TAG, "üîç YouTube Music URL, should redirect: $result (preferred platform: $preferredPlatform)")
                result
            }
            url.contains(SHAZAM_SONG_PATTERN) -> {
                val result = preferencesHelper.isShazamRedirectionEnabled()
                Log.d(TAG, "üîç Shazam URL, should redirect: $result")
                result
            }
            else -> {
                Log.d(TAG, "‚ùì Unknown URL pattern, no redirect")
                false
            }
        }
    }
    
    private fun showErrorAndExit(message: String) {
        Log.e(TAG, "‚ùå Error: $message")
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
        finish()
    }

    private fun isYouTubeMusicEnabled(): Boolean {
        return try {
            packageManager.getApplicationInfo(YOUTUBE_MUSIC_PACKAGE, 0).enabled
        } catch (e: PackageManager.NameNotFoundException) {
            false
        }
    }

    private fun showYouTubeMusicWarning() {
        val message = "YouTube Music app is preventing link interception. To use this feature:\n\n" +
                     "1. Go to Settings > Apps\n" +
                     "2. Find 'YouTube Music'\n" +
                     "3. Select 'Disable' or 'Turn off'\n\n" +
                     "This only needs to be done once."
        
        Log.i(TAG, "‚ÑπÔ∏è Showing YouTube Music warning")
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
        
        androidx.appcompat.app.AlertDialog.Builder(this)
            .setTitle("Action Required")
            .setMessage(message)
            .setPositiveButton("Open Settings") { _, _ ->
                try {
                    val intent = Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
                        data = Uri.parse("package:$YOUTUBE_MUSIC_PACKAGE")
                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    }
                    startActivity(intent)
                } catch (e: Exception) {
                    Log.e(TAG, "‚ùå Error opening settings: ${e.message}")
                }
            }
            .setNegativeButton("Cancel", null)
            .show()
    }

    private fun getPlatformName(platform: String): String {
        return when (platform) {
            PreferencesHelper.PLATFORM_SPOTIFY -> "Spotify"
            PreferencesHelper.PLATFORM_YOUTUBE_MUSIC -> "YouTube Music"
            else -> "music app"
        }
    }

    private fun showProgress(message: String) {
        statusText.text = message
        progressOverlay.visibility = View.VISIBLE
    }

    private fun showSpotifyInstallPrompt() {
        val preferredPlatform = preferencesHelper.getPreferredPlatform()
        val message: String
        val title: String
        val buttonText: String
        
        if (preferredPlatform == PreferencesHelper.PLATFORM_SPOTIFY) {
            // In YouTube Music ‚Üí Spotify mode, we need Spotify installed
            message = "Spotify is not installed on your device. Please install it to use this feature."
            title = "Install Spotify"
            buttonText = "Install Spotify"
        } else {
            // In Spotify ‚Üí YouTube Music mode, we actually need Spotify NOT installed
            message = "Spotify is not available. Make sure YouTube Music is installed to use this feature."
            title = "Check Configuration"
            buttonText = "Install YouTube Music"
        }
        
        Log.i(TAG, "‚ÑπÔ∏è Showing Spotify installation prompt")
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
        
        androidx.appcompat.app.AlertDialog.Builder(this)
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton(buttonText) { _, _ ->
                try {
                    val packageToInstall = if (preferredPlatform == PreferencesHelper.PLATFORM_SPOTIFY) {
                        SPOTIFY_PACKAGE
                    } else {
                        YOUTUBE_MUSIC_PACKAGE
                    }
                    
                    val intent = Intent(Intent.ACTION_VIEW).apply {
                        data = Uri.parse("market://details?id=$packageToInstall")
                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    }
                    startActivity(intent)
                } catch (e: Exception) {
                    Log.e(TAG, "‚ùå Error opening app installation page: ${e.message}")
                }
            }
            .setNegativeButton("Cancel", null)
            .show()
    }

    private fun showYouTubeMusicInstallPrompt() {
        val message = "YouTube Music is not installed on your device. Please install it to use this feature."
        
        Log.i(TAG, "‚ÑπÔ∏è Showing YouTube Music installation prompt")
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
        
        androidx.appcompat.app.AlertDialog.Builder(this)
            .setTitle("Action Required")
            .setMessage(message)
            .setPositiveButton("Install YouTube Music") { _, _ ->
                try {
                    val intent = Intent(Intent.ACTION_VIEW).apply {
                        data = Uri.parse("market://details?id=$YOUTUBE_MUSIC_PACKAGE")
                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    }
                    startActivity(intent)
                } catch (e: Exception) {
                    Log.e(TAG, "‚ùå Error opening YouTube Music installation page: ${e.message}")
                }
            }
            .setNegativeButton("Cancel", null)
            .show()
    }

    private fun isSpotifyInstalledButDisabled(): Boolean {
        try {
            val appInfo = packageManager.getApplicationInfo(SPOTIFY_PACKAGE, PackageManager.GET_META_DATA)
            return !appInfo.enabled
        } catch (e: PackageManager.NameNotFoundException) {
            return false
        }
    }

    private fun showSpotifyDisabledPrompt() {
        val message = "Spotify is installed but disabled on your device. Please enable it to use this feature."
        
        Log.i(TAG, "‚ÑπÔ∏è Showing Spotify disabled prompt")
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
        
        androidx.appcompat.app.AlertDialog.Builder(this)
            .setTitle("Enable Spotify")
            .setMessage(message)
            .setPositiveButton("Open Settings") { _, _ ->
                try {
                    // Open app settings directly
                    val intent = Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
                        data = Uri.parse("package:$SPOTIFY_PACKAGE")
                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    }
                    startActivity(intent)
                } catch (e: Exception) {
                    Log.e(TAG, "‚ùå Error opening Spotify settings: ${e.message}")
                    try {
                        // Fallback to play store
                        val marketIntent = Intent(Intent.ACTION_VIEW).apply {
                            data = Uri.parse("market://details?id=$SPOTIFY_PACKAGE")
                            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                        }
                        startActivity(marketIntent)
                    } catch (e2: Exception) {
                        Log.e(TAG, "‚ùå Error opening Play Store for Spotify: ${e2.message}")
                    }
                }
            }
            .setNegativeButton("Cancel", null)
            .show()
    }

    /**
     * Checks if YouTube Music is disabled
     */
    private fun isYouTubeMusicDisabled(): Boolean {
        return try {
            val appInfo = packageManager.getApplicationInfo(YOUTUBE_MUSIC_PACKAGE, 0)
            val enabledSetting = packageManager.getApplicationEnabledSetting(YOUTUBE_MUSIC_PACKAGE)
            Log.d(TAG, "üì± Checking YouTube Music status: enabled=${appInfo.enabled}, enabledSetting=$enabledSetting")
            
            // The app is disabled if either check fails
            !appInfo.enabled || enabledSetting == PackageManager.COMPONENT_ENABLED_STATE_DISABLED
        } catch (e: PackageManager.NameNotFoundException) {
            Log.d(TAG, "üì± YouTube Music app not found")
            true // Consider it disabled if not found
        }
    }
    
    /**
     * Shows a prompt to enable YouTube Music
     */
    private fun showYouTubeMusicEnablePrompt() {
        val message = "YouTube Music is installed but disabled on your device. You need to enable it to use this feature."
        
        Log.i(TAG, "‚ÑπÔ∏è Showing YouTube Music enable prompt")
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
        
        androidx.appcompat.app.AlertDialog.Builder(this)
            .setTitle("Enable YouTube Music")
            .setMessage(message)
            .setPositiveButton("Open Settings") { _, _ ->
                try {
                    val intent = Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
                        data = Uri.parse("package:$YOUTUBE_MUSIC_PACKAGE")
                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    }
                    startActivity(intent)
                } catch (e: Exception) {
                    Log.e(TAG, "‚ùå Error opening YouTube Music settings: ${e.message}")
                }
            }
            .setNegativeButton("Cancel", null)
            .show()
    }

    /**
     * Shows an error about circular redirection
     */
    private fun showCircularRedirectionError() {
        val message = "Circular redirection detected. Another app (possibly SongShifter) is set to " +
                    "intercept YouTube Music links. Please disable it in Settings > Apps > Default apps."
        
        Log.e(TAG, "‚ö†Ô∏è " + message)
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
        
        androidx.appcompat.app.AlertDialog.Builder(this)
            .setTitle("Circular Redirection Detected")
            .setMessage(message)
            .setPositiveButton("Open Settings") { _, _ ->
                try {
                    val intent = Intent(android.provider.Settings.ACTION_APPLICATION_SETTINGS)
                    startActivity(intent)
                } catch (e: Exception) {
                    Log.e(TAG, "‚ùå Error opening Settings: ${e.message}")
                }
            }
            .setNegativeButton("Cancel", null)
            .show()
    }
} 